{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Jugnu (Fire-Fly) Fire flies are called Jugnu in Hindi. Jugnu framework is the JavaScript framework for developing Firebase Applications","title":"Jugnu"},{"location":"#jugnu-fire-fly","text":"Fire flies are called Jugnu in Hindi. Jugnu framework is the JavaScript framework for developing Firebase Applications","title":"Jugnu (Fire-Fly)"},{"location":"annotations/","text":"Annotation Details FirebaseCollection() Annotate a class with @FirebaseCollection() . If no parameter is provided, then the class name is taken as the Collection name. If a parameter (of type string) is provided, then the parameter value is taken as Collection Name For e.g. @FirebaseCollection('StudentCollection') class Student{ } In this case the firebase collection is created with name: StudentCollection DocumentKey() Annotate a property with @DocumentKey() This property is used as the key of the document. Specify the key type with one of the following values: User defined Key : The key is defined by the user. Auto Generated Key : The key is automatically generated by Firebase Auto Incremented Key : An auto incrementing key is generated by Firebase Read more about document keys . DocumentField Annotate a property with @DocumentField If any property is NOT annotated with this annotation, this field will NOT be saved in the document. This gives users the flexibility to skip some fields which are not to be saved in documents. StorageFile Annotate a property with @StorageFile Properties annotated like this will be considered as storage file. They will be uploaded into the Storage bucket. The fields should be of type: jugnu.Types.StorageFile The type definition is as follows: interface StorageFile{ name: String, // Name of file uri: String // The file path } DocumentArrayField If there is an array of other entities, then declare it using the DocumentArrayField . Pass the entity name to the decorator so that the framework can understand the underlying entity object and its annotations. @DocumentArrayField(InvoicePayment) payments: InvoicePayment[]; AutoIncrement Annotate a property with @AutoIncrement Properties annotated like this will be auto incremented at the time of create. Jugnu will create a collection to keep a track of current counter and will incremente the value automatically. SystemAdminData Annotate a property with @SystemAdminData Only one property can be annotated with this. The property should be of type jugnu.Types.SystemAdminData . The type definition is as follows: interface SystemAdminData{ createdBy?: any, createdAt?: Date, changedBy?: any, changedAt?: Date } If any property is annotated like this, Jugnu will set the values automatically at the time of creation.","title":"Annotation Details"},{"location":"annotations/#annotation-details","text":"","title":"Annotation Details"},{"location":"annotations/#firebasecollection","text":"Annotate a class with @FirebaseCollection() . If no parameter is provided, then the class name is taken as the Collection name. If a parameter (of type string) is provided, then the parameter value is taken as Collection Name For e.g. @FirebaseCollection('StudentCollection') class Student{ } In this case the firebase collection is created with name: StudentCollection","title":"FirebaseCollection()"},{"location":"annotations/#documentkey","text":"Annotate a property with @DocumentKey() This property is used as the key of the document. Specify the key type with one of the following values: User defined Key : The key is defined by the user. Auto Generated Key : The key is automatically generated by Firebase Auto Incremented Key : An auto incrementing key is generated by Firebase Read more about document keys .","title":"DocumentKey()"},{"location":"annotations/#documentfield","text":"Annotate a property with @DocumentField If any property is NOT annotated with this annotation, this field will NOT be saved in the document. This gives users the flexibility to skip some fields which are not to be saved in documents.","title":"DocumentField"},{"location":"annotations/#storagefile","text":"Annotate a property with @StorageFile Properties annotated like this will be considered as storage file. They will be uploaded into the Storage bucket. The fields should be of type: jugnu.Types.StorageFile The type definition is as follows: interface StorageFile{ name: String, // Name of file uri: String // The file path }","title":"StorageFile"},{"location":"annotations/#documentarrayfield","text":"If there is an array of other entities, then declare it using the DocumentArrayField . Pass the entity name to the decorator so that the framework can understand the underlying entity object and its annotations. @DocumentArrayField(InvoicePayment) payments: InvoicePayment[];","title":"DocumentArrayField"},{"location":"annotations/#autoincrement","text":"Annotate a property with @AutoIncrement Properties annotated like this will be auto incremented at the time of create. Jugnu will create a collection to keep a track of current counter and will incremente the value automatically.","title":"AutoIncrement"},{"location":"annotations/#systemadmindata","text":"Annotate a property with @SystemAdminData Only one property can be annotated with this. The property should be of type jugnu.Types.SystemAdminData . The type definition is as follows: interface SystemAdminData{ createdBy?: any, createdAt?: Date, changedBy?: any, changedAt?: Date } If any property is annotated like this, Jugnu will set the values automatically at the time of creation.","title":"SystemAdminData"},{"location":"basic_usage/","text":"Usage Jugnu is compaitable with other Javascript frameworks. Annotations Annotate your typescript classes and members. Create any class that represents an entity. @FirebaseCollection() class Person{ @DocumentKey(DocumentKeyType.UserDefined) name: string; @DocumentField age: number; @DocumentField city: string; location?: string; @DocumentField phone: string; constructor(name: string){ this.name = name; } } Create Document const personCollection = jugnu.createFirebaseCollection(Person); const varun = new Person(\"Varun Verma\"); varun.age = 25; varun.location = \"India\"; varun.city = \"Bangalore\"; varun.phone = \"+91-1234567890\"; personCollection.create(varun); If a field is not annotated with @DocumentField , then it wont be saved. Query Documents The query function takes where conditions as defined by the Firebase const personList: Person[]; const searchCondition = [{ field: \"city\", condition: \"==\", value: \"Bangalore\" }]; personList = await personCollection.query(searchCondition); console.log(personList); To query all documents -- pass empty search condition personList = await personCollection.query([]); Query Single Document with Key let p: Person; p = await personCollection.getDocument(\"Varun Verma\"); console.log(\"Person Details\", p); Update an Document let p: Person; p = await personCollection.getDocument(\"Varun Verma\"); p.city = \"Delhi\"; personCollection.update(p); Delete Document await personCollection.delete(varun);","title":"Usage"},{"location":"basic_usage/#usage","text":"Jugnu is compaitable with other Javascript frameworks.","title":"Usage"},{"location":"basic_usage/#annotations","text":"Annotate your typescript classes and members. Create any class that represents an entity. @FirebaseCollection() class Person{ @DocumentKey(DocumentKeyType.UserDefined) name: string; @DocumentField age: number; @DocumentField city: string; location?: string; @DocumentField phone: string; constructor(name: string){ this.name = name; } }","title":"Annotations"},{"location":"basic_usage/#create-document","text":"const personCollection = jugnu.createFirebaseCollection(Person); const varun = new Person(\"Varun Verma\"); varun.age = 25; varun.location = \"India\"; varun.city = \"Bangalore\"; varun.phone = \"+91-1234567890\"; personCollection.create(varun); If a field is not annotated with @DocumentField , then it wont be saved.","title":"Create Document"},{"location":"basic_usage/#query-documents","text":"The query function takes where conditions as defined by the Firebase const personList: Person[]; const searchCondition = [{ field: \"city\", condition: \"==\", value: \"Bangalore\" }]; personList = await personCollection.query(searchCondition); console.log(personList); To query all documents -- pass empty search condition personList = await personCollection.query([]);","title":"Query Documents"},{"location":"basic_usage/#query-single-document-with-key","text":"let p: Person; p = await personCollection.getDocument(\"Varun Verma\"); console.log(\"Person Details\", p);","title":"Query Single Document with Key"},{"location":"basic_usage/#update-an-document","text":"let p: Person; p = await personCollection.getDocument(\"Varun Verma\"); p.city = \"Delhi\"; personCollection.update(p);","title":"Update an Document"},{"location":"basic_usage/#delete-document","text":"await personCollection.delete(varun);","title":"Delete Document"},{"location":"document_keys/","text":"Document Keys With Jugnu Framework - you can choose to define document keys yourself or leave to Firebase / Jugnu to generate a key. This is achieved by defining the key type in document key annotation. User Defined Key Annotate your class property with @DocumentKey(DocumentKeyType.UserDefined) . In this case, the document key must be defined by the application. The application must ensure that the key is uninue. If the value of the key is not set at the time of entity creation, then Firebse will throw an exception. If the key already exists, then the old document will be updated. Auto Generated Key Annotate your class property with @DocumentKey(DocumentKeyType.GeneratedKey) . In this case, the key is generated by the Firebase. The create method will return back the key generated. @FirebaseCollection() class OrderAddress { @DocumentKey(DocumentKeyType.GeneratedKey) addrKey?: String; // Will be set by Firebase @DocumentField streetName?: String; @DocumentField houseNumer?: String; } const addressCollection = jugnu.createFirebaseCollection(OrderAddress); const address = new OrderAddress(); address.houseNumer = \"H No\"; address.streetName = \"My Street\"; // Create method will return the generated key address.addrKey = await addressCollection.create(address); Auto Incremented Key Annotate your class property with @DocumentKey(DocumentKeyType.AutoIncrement) . In this case, Firebase will generate a key from a sequence. The key is not a random string. The create method will return the generated key. The behaviour is somewhat similar to Auto Increment in mySQL DBs. Behind the scenes, Jugnu will create a new collection to keep a track of counters. Everytime a create method is called, the counter will be incremented by 1. @FirebaseCollection() class SalesOrder { @DocumentKey(DocumentKeyType.AutoIncrement) id?: string; @DocumentField totalAmount: number = 0; @DocumentField orderDate: Date; constructor(){ this.orderDate = new Date(); } } const orderCollection = jugnu.createFirebaseCollection(SalesOrder); const order = new SalesOrder(); order.totalAmount = 100; const orderId = await orderCollection.create(order); console.log(order);","title":"Document Keys"},{"location":"document_keys/#document-keys","text":"With Jugnu Framework - you can choose to define document keys yourself or leave to Firebase / Jugnu to generate a key. This is achieved by defining the key type in document key annotation.","title":"Document Keys"},{"location":"document_keys/#user-defined-key","text":"Annotate your class property with @DocumentKey(DocumentKeyType.UserDefined) . In this case, the document key must be defined by the application. The application must ensure that the key is uninue. If the value of the key is not set at the time of entity creation, then Firebse will throw an exception. If the key already exists, then the old document will be updated.","title":"User Defined Key"},{"location":"document_keys/#auto-generated-key","text":"Annotate your class property with @DocumentKey(DocumentKeyType.GeneratedKey) . In this case, the key is generated by the Firebase. The create method will return back the key generated. @FirebaseCollection() class OrderAddress { @DocumentKey(DocumentKeyType.GeneratedKey) addrKey?: String; // Will be set by Firebase @DocumentField streetName?: String; @DocumentField houseNumer?: String; } const addressCollection = jugnu.createFirebaseCollection(OrderAddress); const address = new OrderAddress(); address.houseNumer = \"H No\"; address.streetName = \"My Street\"; // Create method will return the generated key address.addrKey = await addressCollection.create(address);","title":"Auto Generated Key"},{"location":"document_keys/#auto-incremented-key","text":"Annotate your class property with @DocumentKey(DocumentKeyType.AutoIncrement) . In this case, Firebase will generate a key from a sequence. The key is not a random string. The create method will return the generated key. The behaviour is somewhat similar to Auto Increment in mySQL DBs. Behind the scenes, Jugnu will create a new collection to keep a track of counters. Everytime a create method is called, the counter will be incremented by 1. @FirebaseCollection() class SalesOrder { @DocumentKey(DocumentKeyType.AutoIncrement) id?: string; @DocumentField totalAmount: number = 0; @DocumentField orderDate: Date; constructor(){ this.orderDate = new Date(); } } const orderCollection = jugnu.createFirebaseCollection(SalesOrder); const order = new SalesOrder(); order.totalAmount = 100; const orderId = await orderCollection.create(order); console.log(order);","title":"Auto Incremented Key"},{"location":"installation/","text":"Installation Include jugnu in your package.json OR Install it : npm install @fire-fly/jugnu","title":"Installation"},{"location":"installation/#installation","text":"Include jugnu in your package.json OR Install it : npm install @fire-fly/jugnu","title":"Installation"},{"location":"limitations/","text":"Known Limitations","title":"Limitations"},{"location":"limitations/#known-limitations","text":"","title":"Known Limitations"},{"location":"pub_sub/","text":"Pub-Sub with Jugnu The aim of Jugnu Framework is to integrate well into the GCP / Firebase Apps. Pub-Sub is an important concept in developing modern applications. So, with Jugnu, we can easily publish Events whenever a document is created / updated or deleted. Annotate the entity class to enable Event Publishing. @FirebaseCollection() @PublishEvent(jugnu.Types.EventName.OnCreate) @PublishEvent(jugnu.Types.EventName.OnUpdate) @PublishEvent(jugnu.Types.EventName.OnDelete) class SalesOrder { @DocumentKey(jugnu.Types.DocumentKeyType.AutoIncrement) id: string; @DocumentField totalAmount: number = 0; @DocumentField orderDate: Date; @DocumentField @SystemAdminData sysAdminData?: jugnu.Types.SystemAdminData; constructor(){ this.orderDate = new Date(); } } const orderCollection = jugnu.createFirebaseCollection(SalesOrder); // Create a new Order. const order = new SalesOrder(); const id = await orderCollection.create(order); // After order create, an event will automatically be published. order.totalAmount = order.totalAmount + 100; orderCollection.update(order); // After order create, an event will automatically be published. await orderCollection.delete(order); // After order create, an event will automatically be published. Topic Names If a topic name is explicitly specified, its taken. Otherwise, the topic name is automatically generated. The topic name is generated as follows: {{EventName}}-{{EntityName}} . For e.g. the topic name will be as follows: - On create of SalesOrder : OnCreated-SalesOrder - On update of SalesOrder : OnUpdate-SalesOrder - On delete of SalesOrder : OnDelete-SalesOrder If the topic does not exist already, then a topic will be created.","title":"Pub-Sub"},{"location":"pub_sub/#pub-sub-with-jugnu","text":"The aim of Jugnu Framework is to integrate well into the GCP / Firebase Apps. Pub-Sub is an important concept in developing modern applications. So, with Jugnu, we can easily publish Events whenever a document is created / updated or deleted. Annotate the entity class to enable Event Publishing. @FirebaseCollection() @PublishEvent(jugnu.Types.EventName.OnCreate) @PublishEvent(jugnu.Types.EventName.OnUpdate) @PublishEvent(jugnu.Types.EventName.OnDelete) class SalesOrder { @DocumentKey(jugnu.Types.DocumentKeyType.AutoIncrement) id: string; @DocumentField totalAmount: number = 0; @DocumentField orderDate: Date; @DocumentField @SystemAdminData sysAdminData?: jugnu.Types.SystemAdminData; constructor(){ this.orderDate = new Date(); } } const orderCollection = jugnu.createFirebaseCollection(SalesOrder); // Create a new Order. const order = new SalesOrder(); const id = await orderCollection.create(order); // After order create, an event will automatically be published. order.totalAmount = order.totalAmount + 100; orderCollection.update(order); // After order create, an event will automatically be published. await orderCollection.delete(order); // After order create, an event will automatically be published.","title":"Pub-Sub with Jugnu"},{"location":"pub_sub/#topic-names","text":"If a topic name is explicitly specified, its taken. Otherwise, the topic name is automatically generated. The topic name is generated as follows: {{EventName}}-{{EntityName}} . For e.g. the topic name will be as follows: - On create of SalesOrder : OnCreated-SalesOrder - On update of SalesOrder : OnUpdate-SalesOrder - On delete of SalesOrder : OnDelete-SalesOrder If the topic does not exist already, then a topic will be created.","title":"Topic Names"},{"location":"reference_collections/","text":"Reference Collections Firebase allows you to reference documents of other collections. Consider the example below of Person and Anddress @FirebaseCollection() class Address { @DocumentKey(DocumentKeyType.UserDefined) addrKey: String = \"\"; @DocumentField streetName?: String; @DocumentField houseNumer?: String; } The Person document has a address field that stores reference to the address @FirebaseCollection() class Person{ @DocumentKey(DocumentKeyType.UserDefined) name: String; @DocumentField age: Number; location?: String; @DocumentField phone: String; @DocumentField homeAddress?: Address; constructor(name: String){ this.name = name; } } Create Document Create the address by the normal method. const addressCollection = jugnu.createFirebaseCollection(Address); const addr = new Address(); addr.addrKey = \"Varun-Addr\"; addr.streetName = \"My Street Address\"; addr.houseNumer = \"My House No\"; addressCollection.create(addr); // Create new Address Create person, with reference to Address. const personCollection = jugnu.createFirebaseCollection(Person); const varun = new Person(\"Varun Verma\"); varun.age = 25; varun.location = \"India\"; varun.phone = \"+91-1234567890\"; varun.homeAddress = addr; // Set address in Person personCollection.create(varun); The person document is created with Address as a reference document Creating Document with collection of references We have seen how to store the refence of other documents. Sometimes, we have to store a collection of document references. For e.g. store a list of many children in a Person Profile. @FirebaseCollection() class Person { @DocumentKey(jugnu.Types.DocumentKeyType.UserDefined) id: string; @DocumentField name: string; @DocumentField parent: Person; // Reference to Self Collection @DocumentArrayField(Person) children: Person[]; // Reference to Self Collection constructor(id: string){ this.id = this.name = id; this.children = []; } } const createFunction = async() => { const vv = new Person(\"Varun\"); vv.parent = new Person(\"Papa\"); const beta = new Person(\"Beta\"); const beti = new Person(\"Beti\"); vv.children.push(beta); vv.children.push(beti); const id = await personCollection.create(vv); console.log(vv); }; The peron document is created with references Query Single Document with Key Querying document will also query the referenced documents and populate their properties. let p: Person; p = await personCollection.getDocument(\"Varun Verma\"); console.log(\"Person Details\", p); The output will be: Person { age: 25, phone: '+91-1234567890', homeAddress: { houseNumer: 'My House No', addrKey: 'Varun-Addr', streetName: 'My Street Address' }, name: 'Varun Verma' } Get Reference of the document To get a reference of the document : const addr = new Address(\"Home\"); const addressRef = addressCollection.getReference(addr); Delete Document Delete will delete only the main document. The referenced document will not be deleted.","title":"Reference Collections"},{"location":"reference_collections/#reference-collections","text":"Firebase allows you to reference documents of other collections. Consider the example below of Person and Anddress @FirebaseCollection() class Address { @DocumentKey(DocumentKeyType.UserDefined) addrKey: String = \"\"; @DocumentField streetName?: String; @DocumentField houseNumer?: String; } The Person document has a address field that stores reference to the address @FirebaseCollection() class Person{ @DocumentKey(DocumentKeyType.UserDefined) name: String; @DocumentField age: Number; location?: String; @DocumentField phone: String; @DocumentField homeAddress?: Address; constructor(name: String){ this.name = name; } }","title":"Reference Collections"},{"location":"reference_collections/#create-document","text":"Create the address by the normal method. const addressCollection = jugnu.createFirebaseCollection(Address); const addr = new Address(); addr.addrKey = \"Varun-Addr\"; addr.streetName = \"My Street Address\"; addr.houseNumer = \"My House No\"; addressCollection.create(addr); // Create new Address Create person, with reference to Address. const personCollection = jugnu.createFirebaseCollection(Person); const varun = new Person(\"Varun Verma\"); varun.age = 25; varun.location = \"India\"; varun.phone = \"+91-1234567890\"; varun.homeAddress = addr; // Set address in Person personCollection.create(varun); The person document is created with Address as a reference document","title":"Create Document"},{"location":"reference_collections/#creating-document-with-collection-of-references","text":"We have seen how to store the refence of other documents. Sometimes, we have to store a collection of document references. For e.g. store a list of many children in a Person Profile. @FirebaseCollection() class Person { @DocumentKey(jugnu.Types.DocumentKeyType.UserDefined) id: string; @DocumentField name: string; @DocumentField parent: Person; // Reference to Self Collection @DocumentArrayField(Person) children: Person[]; // Reference to Self Collection constructor(id: string){ this.id = this.name = id; this.children = []; } } const createFunction = async() => { const vv = new Person(\"Varun\"); vv.parent = new Person(\"Papa\"); const beta = new Person(\"Beta\"); const beti = new Person(\"Beti\"); vv.children.push(beta); vv.children.push(beti); const id = await personCollection.create(vv); console.log(vv); }; The peron document is created with references","title":"Creating Document with collection of references"},{"location":"reference_collections/#query-single-document-with-key","text":"Querying document will also query the referenced documents and populate their properties. let p: Person; p = await personCollection.getDocument(\"Varun Verma\"); console.log(\"Person Details\", p); The output will be: Person { age: 25, phone: '+91-1234567890', homeAddress: { houseNumer: 'My House No', addrKey: 'Varun-Addr', streetName: 'My Street Address' }, name: 'Varun Verma' }","title":"Query Single Document with Key"},{"location":"reference_collections/#get-reference-of-the-document","text":"To get a reference of the document : const addr = new Address(\"Home\"); const addressRef = addressCollection.getReference(addr);","title":"Get Reference of the document"},{"location":"reference_collections/#delete-document","text":"Delete will delete only the main document. The referenced document will not be deleted.","title":"Delete Document"}]}